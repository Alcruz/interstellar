
\section{Explicit scheme for Company transformation} \label{sec:company_explicit_scheme}
The explicit scheme is given by
\begin{equation*}
    \begin{split}
      \dfrac{v^{n+1}_{i} - v^{n}_{i}}{\Delta{t}} & - \dfrac{1}{2}\sigma^2 \dfrac{v^{n}_{i-1} - 2v^{n}_{i} + v^{n}_{i+1}}{(\Delta{x})^2} \\ 
       & - \bigg( (r-\delta) - \dfrac{\sigma^2}{2} - \dfrac{\bar{S}^{n+1}_{f} - \bar{S}^{n}_{f}}{\Delta{t}\bar{S}^{n}_{f}} \bigg)\dfrac{v^{n}_{i+1} - v^{n}_{i-1}}{2\Delta{x}} + rv^{n}_{i} = 0
    \end{split}
\end{equation*}
for $i=1\dots,M$ and $n = 0,\dots,N$. 
\begin{equation*}
    \begin{split}
        v^{n+1}_{i} = av^{n}_{i-1} + bv^{n}_{i} + cv^{n}_{i+1} + \dfrac{\bar{S}^{n+1}_{f} - \bar{S}^{n}_{f}}{2\Delta{x}\bar{S}^{n}_{f}}(v^{n}_{i+1} - v^{n}_{i-1})
    \end{split}
\end{equation*}
where 
\begin{equation*}
    \begin{split}
        \lambda =& \dfrac{\Delta{t}}{\Delta{x}^2}\\
        a =& \dfrac{\lambda}{2}\bigg( \sigma^2 - \bigg(r - \delta - \dfrac{\sigma^2}{2}\bigg)\Delta{x} \bigg) \\
        b =& 1 - \sigma^2\lambda- r\Delta{t} \\
        c =& \dfrac{\lambda}{2}\bigg(\sigma^2 + \bigg(r - \delta - \dfrac{\sigma^2}{2}\bigg)\Delta{x}\bigg)
    \end{split}
\end{equation*}
Moreover, the boundary conditions 
\begin{equation*}
    \begin{split}
        \text{\textbf{Call:}} \qquad & v^{n}_{0} = 0, \quad v^{n}_{M+1} = \bar{S}^{n}_{f} - 1 \\
        \text{\textbf{Put:}} \qquad & v^{n}_{0} = 1 - \bar{S}^{n}_{f}, \quad v^{n}_{M+1} = 0 \\
    \end{split}
\end{equation*}
for $n=0,\dots,N$. Moreover, the contact point condition is approximated using central finite difference
\begin{align*}
    \text{\textbf{Call:}} \qquad & \dfrac{v^{n}_{M+2} - v^{n}_{M}}{2\Delta{x}^2} = \dfrac{\partial{v}}{\partial{x}}(0, t) + O(\Delta{x}^2) \\
    \text{\textbf{Put:}} \qquad & \dfrac{v^{n}_{1} - v^{n}_{-1}}{2\Delta{x}} = \dfrac{\partial{v}}{\partial{x}}(0, t)+ O(\Delta{x}^2) 
\end{align*}

for $n=0,\dots,N$. Moreover, the contact point condition is approximated using central finite difference
\begin{align}
    \label{eq:appendix:explicitmethodcompany:contact_point_approximation}
    \text{\textbf{Call:}} \qquad & \dfrac{v^{n}_{M+2} - v^{n}_{M}}{2\Delta{x}^2} = \bar{S}^{n}_{f} \\
    \text{\textbf{Put:}} \qquad & \dfrac{v^{n}_{1} - v^{n}_{-1}}{2\Delta{x}}  = -\bar{S}^{n}_{f}  
\end{align}

By combining the central difference approximation for the PDE, the boundary conditions and the contact point, it is obtained 

\begin{align*}
    \text{\textbf{Call:}} \qquad & v^{n}_{M} =  \\
    \text{\textbf{Put:}} \qquad & v^{n}_{1} = \alpha - \beta\bar{S}^{n}_{f}  
\end{align*}

\begin{algorithm}[H]
    \caption{Explicit method for put options}\label{alg:appendix:companytransformation:explicits:put_explicit_method_algorithm}
    \begin{algorithmic}
    \For{$i = 0,\dots,M+1$} 
      \State $v^{0}_i = 0 $
    \EndFor
    \State $\bar{S}_{f}^{0} = K$

    \State $a = \dfrac{\lambda}{2}\bigg(\sigma^2 - \bigg(r - \delta - \dfrac{\sigma^2}{2}\bigg)\Delta{x}\bigg)$
    \State $b = 1 - \sigma^2\lambda- r\Delta{t} $
    \State $c = \dfrac{\lambda}{2}\bigg(\sigma^2 + \bigg(r - \delta - \dfrac{\sigma^2}{2}\bigg)\Delta{x}\bigg)$
    \State $\alpha = 1 + \dfrac{r\Delta{x}^2}{\sigma^2}$
    \State $\beta = 1 + \Delta{x} + \dfrac{1}{2}\Delta{x}^2$

    \For{$n = 0, \dots, N$}
      \State $d^n = \dfrac{\alpha - (av^{n}_{0} + bv^{0}_{1} + cv^{n}_{2} - (v^{n}_{2} - v^{n}_{0})/(2\Delta{x}))}{(v^{n}_{2} - v^{n}_{0})/(2\Delta{x}) + \beta\bar{S}^{n}_f}$
      \State $\bar{S}^{n+1}_{f}=d^{n}\bar{S}^{n}_{f}$
      \State $a^{n} = a - \dfrac{\bar{S}^{n+1}_{f} - \bar{S}^{n}_{f}}{2\Delta{x}\bar{S}^{n}_{f}}$
      \State $c^{n} = c - \dfrac{\bar{S}^{n+1} - \bar{S}^{n}}{2\Delta{x}\bar{S}^{n}_{f}}$

      \State $v^{n+1}_{0}=1 - \bar{S}^{n+1}_{f}$
      \State $v^{n+1}_{1}=\alpha - \beta\bar{S}^{n+1}_{f}$
      \State $v^{n+1}_{M+1} = 0$
      \For{$i = 2, \dots, M$}
        \State $v^{n+1}_{i} = a^{n} v^{n}_{i-1} + b v^{n}_{i} + c^{n}v^{n}_{i+1}$
      \EndFor
    \EndFor
  \end{algorithmic}
  \end{algorithm}
\section{Python implementation}
The following python code is simplified version of the final implementation. A complete version can be found at \url{https://github.com/Alcruz/math4062-dissertation}.

\begin{lstlisting}[language=Python, caption=Base classses for options solver.]
    class Option(ABC):
        def __init__(self, type: OptionType, K: float, T: float):
            self.type = type
            self.K = K # Strike price
            self.T = T # Maturity

        @abstractmethod
        def payoff(self, S: float):
            pass
    class CallOption(Option):
        def __init__(self, K: float, T: float):
            super().__init__(OptionType.CALL, K, T)
        def payoff(self, S: float):
            return np.maximum(S - self.K, 0) 
    class PutOption(Option):
        def __init__(self, K: float, T: float):
            super().__init__(OptionType.PUT, K, T)
        def payoff(self, S: float):
            return np.maximum(self.K - S, 0)
    class Solver(ABC): 
        def __init__(self, 
            option: Option,
            r: float,  # risk-free interest rate
            sigma: float,  # sigma price volatitliy
            dx: float,  # grid resolution along x-axis
            dt: float,  # grid resolution along t-axis
            delta # dividends
        ) -> None:
            self.option = option
            self.r = r
            self.sigma = sigma
            self.dx = dx
            self.dt = dt
            self.delta = delta
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=Explicit solver for Nielsen transformation.]
    class ExplicitSolver(Solver):
        def __init__(self, 
            option: Option,
            r: float,  # risk-free interest rate
            sigma: float,  # sigma price volatitliy
            dx: float,  # grid resolution along x-axis
            dt: float,  # grid resolution along t-axis
            delta # dividends
        ) -> None:
            self.option = option
            self.r = r
            self.sigma = sigma
            self.dx = dx
            self.dt = dt
            self.delta = delta
            lambd = dt / np.power(dx, 2)
            alpha = dt / dx
            self.A = 0.5 * np.power(sigma*self.x_axis, 2) * lambd - 0.5 * self.x_axis * ((r-delta) - (1/dt)) * alpha
            self.B = 1 - np.power(sigma*self.x_axis, 2) * lambd - r*dt
            self.C = 0.5 * np.power(sigma*self.x_axis, 2) * lambd + 0.5 * self.x_axis * ((r-delta) - (1/dt)) * alpha
        def solve(self):
            V = np.zeros_like(self.x_axis)
            S_bar = self.option.K
            for _ in np.arange(0, self.option.T, self.dt):
                D = 0.5*self.x_axis/self.dx
                D[1:-1] *= (V[2:]-V[:-2]) * (1/S_bar)
                
                S_bar = self.compute_time_iteration(V, D)
            return S_bar*self.x_axis, V, S_bar
        @abstractmethod
        def compute_time_iteration(self, V: np.ndarray, D: np.ndarray):
            pass
    class CallOptionExplicitSolver(ExplicitSolver):
        def __init__(self, 
            option: CallOption,
            r: float,  # risk-free interest rate
            sigma: float,  # sigma price volatitliy
            dx: float,  # grid resolution along x-axis
            dt: float,  # grid resolution along t-axis
            delta=0  # dividends
        ):
            self.x_axis = np.arange(0, 1+dx, dx)
            super().__init__(option, r, sigma, dx, dt, delta)
        def compute_time_iteration(self, V: np.ndarray, D: np.ndarray):
            S_bar = self.option.K + self.A[-2]*V[-3] + self.B[-2]*V[-2] + self.C[-2]*V[-1]
            S_bar /= 1 - self.dx - D[-2]
    
            V[1:-2] = self.A[1:-2]*V[:-3] + self.B[1:-2]*V[1:-2] \
                + self.C[1:-2]*V[2:-1] + D[1:-2]*S_bar
            V[-2] = (1-self.dx)*S_bar - self.option.K
            V[-1] = S_bar - self.option.K
            return S_bar
    class PutOptionExplicitSolver(ExplicitSolver):
        def __init__(self, 
            option: PutOption,
            r: float,  # risk-free interest rate
            sigma: float,  # sigma price volatitliy
            dx: float,  # grid resolution along x-axis
            dt: float,  # grid resolution along t-axis
            x_max: 2.,  # sufficiently large value for x
            delta=0  # dividends
        ):
            self.x_axis = np.arange(1, x_max+dx, dx)
            super().__init__(option, r, sigma, dx, dt, delta)
        def compute_time_iteration(self, V: np.ndarray, D: np.ndarray) -> float:
            S_bar = self.option.K - (self.A[1]*V[0] + self.B[1]*V[1] + self.C[1]*V[2])
            S_bar /= D[1] + 1 + self.dx
            V[2:-1] = self.A[2:-1]*V[1:-2] + self.B[2:-1] * \
                V[2:-1] + self.C[2:-1]*V[3:] + D[2:-1]*S_bar
            V[0] = self.option.payoff(S_bar)
            V[1] = self.option.payoff((1+self.dx)*S_bar)
            return S_bar
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Implicit solver for Nielsen transformation]
class ImplicitSolver(Solver):
    def __init__(self, 
        option: Option,
        r: float,  # risk-free interest rate
        sigma: float,  # sigma price volatitliy
        dx: float,  # grid resolution along x-axis
        dt: float,  # grid resolution along t-axis
        delta=0, # dividends
    ) -> None:
        self.option = option
        self.r = r
        self.sigma = sigma
        self.dx = dx
        self.dt = dt
        self.delta = delta
        self.lambd = self.dt/np.power(self.dx, 2)
        self.kappa = self.dt/self.dx
        self.alpha = 1 + self.lambd*np.power(self.sigma*self.x_axis, 2) + self.r*self.dt
        self.M = self.x_axis.size 
    def beta(self, S, S_bar):
        return -0.5*self.lambd*np.power(self.sigma, 2)*np.power(self.x_axis, 2) + 0.5*self.kappa*self.x_axis*((self.r-self.delta) - (S_bar - S)/(self.dt*S))
    def gamma(self, S, S_bar):
        return -0.5*self.lambd*np.power(self.sigma, 2)*np.power(self.x_axis, 2) - 0.5*self.kappa*self.x_axis*((self.r-self.delta) - (S_bar - S)/(self.dt*S))
    @abstractmethod
    def solve_non_linear_system(self, V, S_bar) -> float:
        pass
    def solve(self):
        S_bar = self.option.K
        V = np.zeros_like(self.x_axis)
        for _ in np.arange(0, self.option.T, self.dt):
            S_bar = self.solve_non_linear_system(V, S_bar)
        return S_bar*self.x_axis, V, S_bar
class CallOptionImplicitSolver(ImplicitSolver):
    def __init__(self, 
        option: Option,
        r: float,  # risk-free interest rate
        sigma: float,  # sigma price volatitliy
        dx: float,  # grid resolution along x-axis
        dt: float,  # grid resolution along t-axis
        delta=0, #dividends
        maxiter=1000,
        tolerance=1e-24,
        method='lm'
    ) -> None:
        self.x_axis = np.arange(0, 1+dx, dx)
        super().__init__(option, r, sigma, dx, dt, delta)
        self.maxiter=maxiter
        self.tolerance=tolerance
        self.method=method
    def jacobian(self, y, S_bar):
        p, s, = y[:-1], y[-1]
        beta = self.beta(s, S_bar)
        gamma = self.gamma(s, S_bar)
        dgamma_ds = - 0.5 * (1/self.dx) * self.x_axis * S_bar / s**2
        dbeta_ds = 0.5 * (1/self.dx) * self.x_axis * S_bar / s**2
        retVal = diags([self.alpha[2:], beta[1:-1], gamma[1:-1]],
                    [-1, 0, 1], shape=(self.M-2, self.M-2)).toarray()
        retVal[-1, :] = 0
        retVal[:, -1] = 0
        retVal[0, -1] = dbeta_ds[1]*p[0] + dgamma_ds[1]*p[1]
        retVal[1:-2, -1] = dbeta_ds[2:-3]*p[1:-1] + dgamma_ds[2:-3]*p[2:]
        retVal[-2, -1] = dbeta_ds[-3]*p[-2]
        retVal[-2, -1] -= dgamma_ds[-3]*self.option.payoff((1-self.dx)*s) + gamma[-3]*(1 - self.dx)
        retVal[-1, -2] = self.alpha[-2]
        retVal[-1, -1] -= dgamma_ds[-2]*self.option.payoff(s) + gamma[-2] + dbeta_ds[-2]*self.option.payoff((1-self.dx)*s) - beta[1]*(1-self.dx)
        return retVal
    def system(self, y, b, S_bar):
        *v, s = y
        beta = self.beta(s, S_bar)
        gamma = self.gamma(s, S_bar)
        A = diags([self.alpha[2:-1], beta[1:-2], gamma[1:-3]],
                [-1, 0, 1], shape=(self.M-2, self.M-3)).toarray()
        f = b[1:-1]
        f[-2] -= gamma[-3]*((1-self.dx)*s-self.option.K)
        f[-1] -= gamma[-2]*(s-self.option.K) + beta[-2]*((1-self.dx)*s - self.option.K)
        res = A@v - f
        return res
    def solve_non_linear_system(self, V: np.ndarray, S_bar: np.ndarray):
        *V[1:-2], S_bar = root(
            lambda y: self.system(y, np.copy(V[:]), S_bar),
            # jac=lambda y: self.jacobian(y, S_bar),
            x0=np.concatenate([V[1:-2], [S_bar]]),
            method=self.method,
            options=dict(xtol=self.tolerance, maxiter=self.maxiter)
        )['x']
        V[-2] = (1-self.dx)*S_bar-self.option.K
        V[-1] = S_bar-self.option.K
        return S_bar
class PutOptionImplicitSolver(ImplicitSolver):
    def __init__(self, 
        option: Option,
        r: float,  # risk-free interest rate
        sigma: float,  # sigma price volatitliy
        dx: float,  # grid resolution along x-axis
        dt: float,  # grid resolution along t-axis
        delta=0, # dividends
        x_max=2,
        maxiter=1000,
        tolerance=1e-24,
        method='lm'
    ) -> None:
        self.x_axis = np.arange(1, x_max+dx, dx)
        super().__init__(option, r, sigma, dx, dt, delta)
        self.maxiter=maxiter
        self.tolerance=tolerance
        self.method=method
    def jacobian(self, y, S_bar):
        p, s, = y[:-1], y[-1]
        beta = self.beta(s, S_bar)
        gamma = self.gamma(s, S_bar)

        dgamma_ds = - 0.5 * (1/self.dx) * self.x_axis * S_bar / s**2
        dbeta_ds = 0.5 * (1/self.dx) * self.x_axis * S_bar / s**2

        retVal = diags([beta[3:-1], self.alpha[2:-1], gamma[1:-1]],
                    [-2, -1, 0], shape=(self.M-2, self.M-2)).toarray()
        retVal[-1, :] = 0
        retVal[:, -1] = 0
        retVal[0, -1] = dgamma_ds[1]*p[0] + dbeta_ds[1] * \
            (self.option.K - S_bar) - beta[1] - self.alpha[1]*(1+self.dx)
        retVal[1, -1] = dgamma_ds[2]*p[1] + dbeta_ds[2] * \
            (self.option.K - (1+self.dx)*S_bar) - beta[2]*(1+self.dx)
        retVal[2:-1, -1] = dbeta_ds[3:-2]*p[:-2] + dgamma_ds[3:-2]*p[2:]
        retVal[-1, -3] = beta[-2]
        retVal[-1, -2] = self.alpha[-2]
        retVal[-1, -1] = dbeta_ds[-2]*p[-2]
        return retVal
    def system(self, y, b, S_bar):
        p, s, = y[:-1], y[-1]
        _beta = self.beta(s, S_bar)
        _gamma = self.gamma(s, S_bar)
        A = diags([_beta[3:-1], self.alpha[2:-1], _gamma[1:-2]],
                [-2, -1, 0], shape=(self.M-2, self.M-3)).toarray()
        f = b[1:-1]
        f[0] -= _beta[1]*(self.option.K-s) + self.alpha[1]*((self.option.K-(1+self.dx)*s))
        f[1] -= _beta[2]*(self.option.K-(1+self.dx)*s)
        res = A@p - f
        return res
    def solve_non_linear_system(self, V: np.ndarray, S_bar: np.ndarray):
        *V[2:-1], S_bar = root(
            lambda y: self.system(y, np.copy(V[:]), S_bar),
            # jac=lambda y: self.jacobian(y, S_bar),
            x0=np.concatenate([V[2:-1], [S_bar]]),
            method=self.method,
            options=dict(xtol=self.tolerance, maxiter=self.maxiter)
        )['x']
        V[0] = self.option.payoff(S_bar)
        V[1] = self.option.payoff((1+self.dx)*S_bar)    
        return S_bar
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=Explicit solver for Company transformation.]
class ExplicitSolver(Solver):
    def __init__(
        self,
        r: float,  # risk-free interest rate
        sigma: float,  # sigma price volatitliy
        dx: float,  # grid resolution along x-axis
        dt: float,  # grid resolution along t-axis
        delta  # dividends
    ): 
        self.r = r
        self.sigma = sigma
        self.dx = dx
        self.dt = dt
        self.delta = delta    
        self.lambd = self.dt / np.power(self.dx,2)
        self.A = np.power(self.sigma, 2)
        self.A -= (self.r-self.delta-0.5*np.power(self.sigma,2))*self.dx
        self.A *= self.lambd / 2
        self.B = 1 - np.power(self.sigma, 2) * self.lambd - self.r*self.dt
        self.C = np.power(self.sigma, 2) 
        self.C += (self.r-self.delta-0.5*np.power(self.sigma,2))*self.dx
        self.C *= self.lambd / 2
    @abstractmethod
    def compute_time_iteration(self, p: np.ndarray, S_bar: float) -> float:
        pass
    def solve(self, option: Option):
            """Solve front-fixing method explicitly.

            Parameters:
                option (AmericanOption): the option to price.
                r (float): the stock price risk-free interest rate.
                sigma (float): the stock price volatility.
                x_max (float): large value used as infity in the spatial.
                dx (float): Grid resolution in the spatial direction.
                dt (float): Grid resolution in the time direction.
            """
            p = np.zeros_like(self.x_axis)
            S_bar = 1
            for _ in np.arange(0, option.T, self.dt):
                S_bar = self.compute_time_iteration(p, S_bar)
            S = S_bar * np.exp(self.x_axis)
            return option.K*S, option.K*p, S_bar
class CallExplicitSolver(ExplicitSolver):
    def __init__(
        self,
        r: float,  # risk-free interest rate
        sigma: float,  # sigma price volatitliy
        x_min: float,  # sufficiently large value for x
        dx: float,  # grid resolution along x-axis
        dt: float,  # grid resolution along t-axis
        delta=0  # dividends
    ):                 
        self.x_axis = np.arange(x_min, dx, dx)
        self.x_axis[-1] = 0
        super().__init__(r=r, sigma=sigma, dx=dx, dt=dt, delta=delta)
        self.alpha = -self.r*np.power(self.dx/self.sigma, 2) - 1
        self.beta = -1 + self.dx - 0.5*np.power(self.dx, 2) - np.power(self.dx/self.sigma, 2)*self.delta 
    def compute_time_iteration(self, p: np.ndarray, S_bar: float) -> float:
        d = self.alpha - (self.A*p[-3] + self.B*p[-2] + self.C*p[-1] - (p[-1]-p[-3])/(2*self.dx))
        d /= (p[-1]-p[-3])/(2*self.dx) + self.beta*S_bar
        S_bar_new = d*S_bar
        a = self.A - (S_bar_new - S_bar)/(2*self.dx*S_bar)
        c = self.C + (S_bar_new- S_bar)/(2*self.dx*S_bar)
        S_bar = S_bar_new
        p[1:-2] = a*p[:-3] + self.B*p[1:-2] + c*p[2:-1]
        p[-2] = self.alpha - self.beta*S_bar 
        p[-1] = S_bar - 1
        return S_bar_new
class PutExplicitSolver(ExplicitSolver):
    def __init__(
        self,
        r: float,  # risk-free interest rate
        sigma: float,  # sigma price volatitliy
        x_max: float,  # sufficiently large value for x
        dx: float,  # grid resolution along x-axis
        dt: float,  # grid resolution along t-axis
        delta=0  # dividends
    ):                 
        self.x_axis = np.arange(0, x_max+dx, dx)
        super().__init__(r=r, sigma=sigma, dx=dx, dt=dt, delta=delta)
        self.alpha = 1 + self.r*np.power(self.dx/self.sigma, 2)
        self.beta = 1 + self.dx + 0.5*np.power(self.dx, 2) + np.power(self.dx/self.sigma, 2)*self.delta 
    def compute_time_iteration(self, p: np.ndarray, S_bar: float) -> float:
        d = self.alpha - (self.A*p[0] + self.B*p[1] + self.C*p[2] - (p[2]-p[0])/(2*self.dx))
        d /= (p[2]-p[0])/(2*self.dx) + self.beta*S_bar
        S_bar_new = d*S_bar

        a = self.A - (S_bar_new - S_bar)/(2*self.dx*S_bar)
        c = self.C + (S_bar_new- S_bar)/(2*self.dx*S_bar)

        p[2:-1] = a*p[1:-2] + self.B*p[2:-1] + c*p[3:]
        p[1] = self.alpha - self.beta*S_bar_new
        p[0] = 1 - S_bar_new
        return S_bar_new    
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=PSOR-LCP solver for Company transformation.]
class LCPSolver:
    def __init__(
        self,
        r: float, 
        sigma: float, 
        dx: float, 
        dt: float,
        x_min = -3.,
        x_max = 3.,
        theta = 0., 
        delta=0.
    ):
        self.r = r
        self.sigma = sigma
        self.dx = dx
        self.dt = dt
        self.x_min = x_min
        self.x_max = x_max
        self.theta = theta
        self.delta = delta
        self.x_axis = np.arange(self.x_min, self.x_max + self.dx, step=self.dx)
    @abstractmethod
    def get_g(self, x_axis, tao_axis, q_delta, q):
        pass
    def solve(
        self,
        option: Option,
        wR = 1,
        eps = 1e-24
    ):
        # Parameters artificail space
        q = (2*self.r) / np.power(self.sigma, 2)
        q_delta = 2*(self.r-self.delta) / np.power(self.sigma, 2)
        t_axis = np.arange(0, option.T+self.dt, step=self.dt)
        tao_axis = 0.5*np.power(self.sigma,2)*t_axis
        dtao = np.diff(tao_axis)[0]
        # calculate lambda and alpha
        lambd = dtao/np.power(self.dx, 2)
        alpha = lambd*self.theta
        g = self.get_g(self.x_axis, tao_axis, q_delta, q)
        # compute initial condition
        w = np.empty(self.x_axis.size)
        w = g[:, 0]
        b = np.empty_like(self.x_axis)
        v_new = np.empty_like(self.x_axis)
        for i in range(tao_axis.size - 1):
            b[2:-2] = w[2:-2] + lambd*(1-self.theta)*(w[3:-1] - 2*w[2:-2] + w[1:-3])
            b[1] = w[1] + lambd*(1-self.theta)*(w[2] -2*w[1] + g[0, i]) + alpha*g[0, i+1]
            b[-2] = w[-2] + lambd*(1-self.theta)*(g[-1, i]-2*w[-2] + w[-3]) + alpha*g[-1, i+1]
            v = np.maximum(w, g[:, i+1])
            while True:
                v_new[0] = v_new[-1] = 0
                for j in range(1, v.size - 1):
                    rho = b[j] + alpha*(v_new[j-1] + v[j+1])
                    rho /= 1+2*alpha
                    v_new[j] = np.maximum(g[j, i+1], v[j] + wR*(rho - v[j]))
                if np.linalg.norm(v_new - v, ord=2) <= eps:
                    break
                v = v_new.copy()
            w = v.copy()
        S_axis = option.K*np.exp(self.x_axis)
        S_axis[0] = 0
        V = self.get_surface(option, w, tao_axis, q, q_delta)
        return S_axis, V
class CallLCPSolver(LCPSolver):
    def __init__(self, r: float, sigma: float, dx: float, dt: float, x_min=-3, x_max=3, theta=0, delta=0):
        super().__init__(r, sigma, dx, dt, x_min, x_max, theta, delta)
    def get_g(self, x_axis, tao_axis, q_delta, q):
        return CallLCPSolver.GUtil(x_axis, tao_axis, q_delta, q)
    def get_early_exercise(self, option, S, V):
        eps = 1e-5
        S_bar = S[np.abs(option.K - S + V) <= eps][-1]
        return S_bar
    def get_surface(self, option, w, tao_axis, q, q_delta, ):
        V = option.K*w*np.exp(-(self.x_axis/2)*(q_delta - 1)) * np.exp(-tao_axis[-1]*((1/4)*np.power(q_delta - 1, 2) + q))
        V[0] = 0
        return V[:]      
    class GUtil: 
        def __init__(self, x, tao, q_delta, q):
            self.x = x
            self.tao = tao
            self.q_delta = q_delta
            self.q = q  
        def __getitem__(self, indx):
            xi, ti = indx
            return self.payoff(self.x[xi], self.tao[ti])
        def payoff(self, x, tao): return np.exp((tao/4)*(np.power(self.q_delta-1, 2) + 4*self.q)) * \
            np.maximum(np.exp((x/2)*(self.q_delta + 1)) - np.exp((x/2)*(self.q_delta - 1)), 0)
class PutLCPSolver(LCPSolver):
    def __init__(self, r: float, sigma: float, dx: float, dt: float, x_min=-3, x_max=3, theta=0, delta=0):
        super().__init__(r, sigma, dx, dt, x_min, x_max, theta, delta)
    def get_g(self, x_axis, tao_axis, q_delta, q):
        return PutLCPSolver.GUtil(x_axis, tao_axis, q_delta, q)
    def get_early_exercise(self, option, S, V):
        eps = 1e-5
        S_bar = S[np.abs(V + S - option.K) <= eps][-1]
        return S_bar
    def get_surface(self, option, w, tao_axis, q, q_delta):
        V = option.K*w*np.exp(-(self.x_axis/2)*(q_delta - 1)) * np.exp(-tao_axis[-1]*((1/4)*np.power(q_delta - 1, 2) + q))
        V[0] = option.K
        return V
    class GUtil: 
        def __init__(self, x, tao, q_delta, q):
            self.x = x
            self.tao = tao
            self.q_delta = q_delta
            self.q = q

        def __getitem__(self, indx):
            xi, ti = indx
            return self.payoff(self.x[xi], self.tao[ti])

        def payoff(self, x, tao): return np.exp((tao/4)*(np.power(self.q_delta-1, 2) + 4*self.q)) * \
            np.maximum(np.exp((x/2)*(self.q_delta - 1)) - np.exp((x/2)*(self.q_delta + 1)), 0)
\end{lstlisting}